<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Lazy-pages support. In runtime data for program Wasm memory pages can be loaded in lazy manner. All pages, which is supposed to be lazy, must be mprotected before program execution. During execution data from storage is loaded for all pages, which has been accessed and which has data in storage. See also `process::process_lazy_pages`, `signal`, `host_func` for more information."><title>gear_lazy_pages - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-84e720fa.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="gear_lazy_pages" data-themes="" data-resource-suffix="" data-rustdoc-version="1.89.0-nightly (ccf3198de 2025-06-05)" data-channel="nightly" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-4e99c027.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-fd3af306.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="icon" href="https://gear-tech.io/favicons/favicon.ico"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../gear_lazy_pages/index.html"><img src="https://docs.gear.rs/logo.svg" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../gear_lazy_pages/index.html"><img src="https://docs.gear.rs/logo.svg" alt="logo"></a><h2><a href="../gear_lazy_pages/index.html">gear_<wbr>lazy_<wbr>pages</a><span class="version">1.9.1</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#structs">Crate Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>gear_lazy_pages</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/gear_lazy_pages/lib.rs.html#19-463">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Lazy-pages support.
In runtime data for program Wasm memory pages can be loaded in lazy manner.
All pages, which is supposed to be lazy, must be mprotected before program execution.
During execution data from storage is loaded for all pages, which has been accessed
and which has data in storage.
See also <code>process::process_lazy_pages</code>, <code>signal</code>, <code>host_func</code> for more information.</p>
<p>Note: currently we restrict twice write signal from same page during one execution.
It’s not necessary behavior, but more simple and safe.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.ExceptionInfo.html" title="struct gear_lazy_pages::ExceptionInfo">Exception<wbr>Info</a></dt></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.Error.html" title="enum gear_lazy_pages::Error">Error</a></dt><dt><a class="enum" href="enum.InitError.html" title="enum gear_lazy_pages::InitError">Init<wbr>Error</a></dt><dt><a class="enum" href="enum.LazyPagesError.html" title="enum gear_lazy_pages::LazyPagesError">Lazy<wbr>Pages<wbr>Error</a></dt><dt><a class="enum" href="enum.LazyPagesVersion.html" title="enum gear_lazy_pages::LazyPagesVersion">Lazy<wbr>Pages<wbr>Version</a></dt><dd>Lazy-pages version.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.LazyPagesStorage.html" title="trait gear_lazy_pages::LazyPagesStorage">Lazy<wbr>Pages<wbr>Storage</a></dt><dt><a class="trait" href="trait.UserSignalHandler.html" title="trait gear_lazy_pages::UserSignalHandler">User<wbr>Signal<wbr>Handler</a></dt></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.change_wasm_mem_addr_and_size.html" title="fn gear_lazy_pages::change_wasm_mem_addr_and_size">change_<wbr>wasm_<wbr>mem_<wbr>addr_<wbr>and_<wbr>size</a></dt><dd>Set current wasm memory begin addr in global context</dd><dt><a class="fn" href="fn.init.html" title="fn gear_lazy_pages::init">init</a></dt><dt><a class="fn" href="fn.init_with_handler.html" title="fn gear_lazy_pages::init_with_handler">init_<wbr>with_<wbr>handler</a></dt><dd>Initialize lazy-pages for current thread.</dd><dt><a class="fn" href="fn.initialize_for_program.html" title="fn gear_lazy_pages::initialize_for_program">initialize_<wbr>for_<wbr>program</a></dt><dt><a class="fn" href="fn.pre_process_memory_accesses.html" title="fn gear_lazy_pages::pre_process_memory_accesses">pre_<wbr>process_<wbr>memory_<wbr>accesses</a></dt><dt><a class="fn" href="fn.set_lazy_pages_protection.html" title="fn gear_lazy_pages::set_lazy_pages_protection">set_<wbr>lazy_<wbr>pages_<wbr>protection</a></dt><dd>Protect lazy pages, after they had been unprotected.</dd><dt><a class="fn" href="fn.status.html" title="fn gear_lazy_pages::status">status</a></dt><dt><a class="fn" href="fn.unset_lazy_pages_protection.html" title="fn gear_lazy_pages::unset_lazy_pages_protection">unset_<wbr>lazy_<wbr>pages_<wbr>protection</a></dt><dd>Unset lazy pages read/write protections.</dd><dt><a class="fn" href="fn.write_accessed_pages.html" title="fn gear_lazy_pages::write_accessed_pages">write_<wbr>accessed_<wbr>pages</a></dt><dd>Returns vec of lazy-pages which has been accessed</dd></dl></section></div></main></body></html>