<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Functions and helpers for creating programs from programs."><title>gstd::prog - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-84e720fa.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="gstd" data-themes="" data-resource-suffix="" data-rustdoc-version="1.89.0-nightly (ccf3198de 2025-06-05)" data-channel="nightly" data-search-js="search-f7877310.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-4e99c027.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-fd3af306.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-32bb7600.css"></noscript><link rel="icon" href="https://gear-tech.io/favicons/favicon.ico"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../gstd/index.html"><img src="https://docs.gear.rs/logo.svg" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../gstd/index.html"><img src="https://docs.gear.rs/logo.svg" alt="logo"></a><h2><a href="../../gstd/index.html">gstd</a><span class="version">1.9.1</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module prog</a></h2><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate gstd</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">gstd</a></div><h1>Module <span>prog</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/gstd/prog/mod.rs.html#19-45">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Functions and helpers for creating programs from programs.</p>
<p>Any program being an actor, can not only process incoming messages and send
outcoming messages to other actors but also create new actors. This feature
can be useful when implementing the factory pattern, as a single
actor can produce multiple derived actors with different input data.</p>
<p>Firstly you need to upload a Wasm code of the future program(s) by calling
<code>gear.uploadCode</code> extrinsic to obtain the corresponding
<a href="../struct.CodeId.html" title="struct gstd::CodeId"><code>CodeId</code></a>.</p>
<p>You must also provide a unique byte sequence to create multiple program
instances from the same code. This sequence is often referenced as <em>salt</em>.
<a href="struct.ProgramGenerator.html" title="struct gstd::prog::ProgramGenerator"><code>ProgramGenerator</code></a> allows generating of salt automatically.</p>
<p>The newly created program should be initialized using a corresponding
payload; therefore, you must provide it when calling any <code>create_program_*</code>
function.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="struct" href="struct.ProgramGenerator.html" title="struct gstd::prog::ProgramGenerator">Program<wbr>Generator</a></dt><dd>Helper to create programs without setting the salt manually.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="fn" href="fn.create_program.html" title="fn gstd::prog::create_program">create_<wbr>program</a></dt><dd>Same as <a href="fn.create_program_bytes.html" title="fn gstd::prog::create_program_bytes"><code>create_program_bytes</code></a>, but allows
initialize program with the encodable payload.</dd><dt><a class="fn" href="fn.create_program_bytes.html" title="fn gstd::prog::create_program_bytes">create_<wbr>program_<wbr>bytes</a></dt><dd>Create a new program from the already existing on-chain code identified by
<a href="../struct.CodeId.html" title="struct gstd::CodeId"><code>CodeId</code></a>.</dd><dt><a class="fn" href="fn.create_program_bytes_delayed.html" title="fn gstd::prog::create_program_bytes_delayed">create_<wbr>program_<wbr>bytes_<wbr>delayed</a></dt><dd>Same as <a href="fn.create_program_bytes.html" title="fn gstd::prog::create_program_bytes"><code>create_program_bytes</code></a>, but creates a new program after the
<code>delay</code> expressed in block count.</dd><dt><a class="fn" href="fn.create_program_bytes_for_reply.html" title="fn gstd::prog::create_program_bytes_for_reply">create_<wbr>program_<wbr>bytes_<wbr>for_<wbr>reply</a></dt><dd>Same as <a href="fn.create_program_bytes.html" title="fn gstd::prog::create_program_bytes"><code>create_program_bytes</code></a>, but the program
will interrupt until the reply is received.</dd><dt><a class="fn" href="fn.create_program_bytes_for_reply_as.html" title="fn gstd::prog::create_program_bytes_for_reply_as">create_<wbr>program_<wbr>bytes_<wbr>for_<wbr>reply_<wbr>as</a></dt><dd>Same as <a href="fn.create_program_bytes.html" title="fn gstd::prog::create_program_bytes"><code>create_program_bytes</code></a>, but the program
will interrupt until the reply is received.</dd><dt><a class="fn" href="fn.create_program_bytes_with_gas.html" title="fn gstd::prog::create_program_bytes_with_gas">create_<wbr>program_<wbr>bytes_<wbr>with_<wbr>gas</a></dt><dd>Same as <a href="fn.create_program_bytes.html" title="fn gstd::prog::create_program_bytes"><code>create_program_bytes</code></a>, but with an explicit gas limit.</dd><dt><a class="fn" href="fn.create_program_bytes_with_gas_delayed.html" title="fn gstd::prog::create_program_bytes_with_gas_delayed">create_<wbr>program_<wbr>bytes_<wbr>with_<wbr>gas_<wbr>delayed</a></dt><dd>Same as <a href="fn.create_program_bytes_with_gas.html" title="fn gstd::prog::create_program_bytes_with_gas"><code>create_program_bytes_with_gas</code></a>, but creates a new program after
the <code>delay</code> expressed in block count.</dd><dt><a class="fn" href="fn.create_program_bytes_with_gas_for_reply.html" title="fn gstd::prog::create_program_bytes_with_gas_for_reply">create_<wbr>program_<wbr>bytes_<wbr>with_<wbr>gas_<wbr>for_<wbr>reply</a></dt><dd>Same as <a href="fn.create_program_bytes_with_gas.html" title="fn gstd::prog::create_program_bytes_with_gas"><code>create_program_bytes_with_gas</code></a>, but the program
will interrupt until the reply is received.</dd><dt><a class="fn" href="fn.create_program_bytes_with_gas_for_reply_as.html" title="fn gstd::prog::create_program_bytes_with_gas_for_reply_as">create_<wbr>program_<wbr>bytes_<wbr>with_<wbr>gas_<wbr>for_<wbr>reply_<wbr>as</a></dt><dd>Same as <a href="fn.create_program_bytes_with_gas.html" title="fn gstd::prog::create_program_bytes_with_gas"><code>create_program_bytes_with_gas</code></a>, but the program
will interrupt until the reply is received.</dd><dt><a class="fn" href="fn.create_program_delayed.html" title="fn gstd::prog::create_program_delayed">create_<wbr>program_<wbr>delayed</a></dt><dd>Same as <a href="fn.create_program.html" title="fn gstd::prog::create_program"><code>create_program</code></a>, but creates a new program after the <code>delay</code>
expressed in block count.</dd><dt><a class="fn" href="fn.create_program_for_reply.html" title="fn gstd::prog::create_program_for_reply">create_<wbr>program_<wbr>for_<wbr>reply</a></dt><dd>Same as <a href="fn.create_program.html" title="fn gstd::prog::create_program"><code>create_program</code></a>, but the program
will interrupt until the reply is received.</dd><dt><a class="fn" href="fn.create_program_for_reply_as.html" title="fn gstd::prog::create_program_for_reply_as">create_<wbr>program_<wbr>for_<wbr>reply_<wbr>as</a></dt><dd>Same as <a href="fn.create_program.html" title="fn gstd::prog::create_program"><code>create_program</code></a>, but the program
will interrupt until the reply is received.</dd><dt><a class="fn" href="fn.create_program_with_gas.html" title="fn gstd::prog::create_program_with_gas">create_<wbr>program_<wbr>with_<wbr>gas</a></dt><dd>Same as <a href="fn.create_program.html" title="fn gstd::prog::create_program"><code>create_program</code></a>, but with an explicit gas limit.</dd><dt><a class="fn" href="fn.create_program_with_gas_delayed.html" title="fn gstd::prog::create_program_with_gas_delayed">create_<wbr>program_<wbr>with_<wbr>gas_<wbr>delayed</a></dt><dd>Same as <a href="fn.create_program_with_gas.html" title="fn gstd::prog::create_program_with_gas"><code>create_program_with_gas</code></a>, but creates a new program after the
<code>delay</code> expressed in block count.</dd><dt><a class="fn" href="fn.create_program_with_gas_for_reply.html" title="fn gstd::prog::create_program_with_gas_for_reply">create_<wbr>program_<wbr>with_<wbr>gas_<wbr>for_<wbr>reply</a></dt><dd>Same as <a href="fn.create_program_with_gas.html" title="fn gstd::prog::create_program_with_gas"><code>create_program_with_gas</code></a>, but the program
will interrupt until the reply is received.</dd><dt><a class="fn" href="fn.create_program_with_gas_for_reply_as.html" title="fn gstd::prog::create_program_with_gas_for_reply_as">create_<wbr>program_<wbr>with_<wbr>gas_<wbr>for_<wbr>reply_<wbr>as</a></dt><dd>Same as <a href="fn.create_program_with_gas.html" title="fn gstd::prog::create_program_with_gas"><code>create_program_with_gas</code></a>, but the program
will interrupt until the reply is received.</dd></dl></section></div></main></body></html>